---
title: "REDCap Annual Project Billing Revenue, Status, and Projections"
author: "Philip Chase"
format:
  html:
    code-fold: true
    code-tools: true
    df-print: kable
  pdf:
    df-print: kable
editor: visual
date: "`r Sys.Date()`"
---

The CTS-IT manages the REDCap system for the UF Clinical Translational Science Institute (CTSI). To generate revenue to cover some of the costs of the running the REDCap System, CTS-IT charges its customers for the REDCap projects they use. These annual charges are assessed on each anniversary of each project via a system named *REDCap Annual Project Billing (APB)*. This report describes that project by assessing the revenue, estimating future revenue, as well as other metrics of growth and performance.

While the original billing system started in July 2018, that system was rewritten from the ground up in 2022. The revision focuses on automated processes to implement a monthly billing cycle and delegates the billing work to the UF CTSI Service Billing Team. The new system was implemented in September 2022.

```{r}
#| label: calcs
#| output: false
#| echo: false
#| warning: false
library(redcapcustodian)
library(rcc.billing)
library(RMariaDB)
library(DBI)
library(tidyverse)
library(lubridate)
library(dotenv)
library(fs)
library(scales)

if (Sys.getenv("RCCBILLING_DB_NAME") == "") dotenv::load_dot_env(here::here("prod.env"))

init_etl("revenue_status_and_projections")

rcc_billing_conn <- connect_to_rcc_billing_db()

invoice_status <-
  tbl(rcc_billing_conn, "invoice_line_item") %>%
  collect() %>%
  mutate(invoice_month = lubridate::floor_date(created - dmonths(1), unit = "month")) %>%
  filter(status %in% c("invoiced", "paid"))

revenue <-
  tbl(rcc_billing_conn, "invoice_line_item") %>%
  collect() %>%
  mutate(invoice_month = lubridate::floor_date(created - dmonths(1), unit = "month")) %>%
  filter(status != "canceled") %>%
  group_by(status, invoice_month) %>%
  summarise(total = sum(amount_due)) %>%
  tidyr::pivot_wider(
    id_cols = c("invoice_month"),
    names_from = status,
    values_from = total
  ) %>%
  mutate(
    invoices_sent = invoiced + coalesce(paid, 0),
    portion_paid = coalesce(paid, 0) / invoices_sent
  )

# the average portion paid should ignore the last three months as sequester_unpaid_projects has not yet been applied to these months
average_portion_paid <- revenue %>%
  slice_head(n = nrow(revenue) - 4) %>%
  summarise(average_portion_paid = mean(portion_paid)) %>%
  pull(average_portion_paid)

expected_revenue <- revenue %>%
  mutate(expected_revenue = case_when(
    row_number() <= nrow(revenue) - 4 ~ paid,
    TRUE ~ round(coalesce(invoices_sent, sent) * average_portion_paid)
  ))

revenue_and_projections <- bind_cols(
  expected_revenue %>%
    summarise(
      actual_revenue = sum(paid, na.rm = T),
      accounts_receivable = sum(invoiced, na.rm = T)
    ),
  # Base expected revenue only on the last 12 months of revenue
  expected_revenue |>
    slice_tail(n = 12) |>
    # correct expected revenue for the rate increase that started 2023-11-01
    mutate(expected_revenue = if_else(invoice_month < ymd("2023-10-15"), expected_revenue * 1.30, expected_revenue)) |>
    summarise(
      expected_monthly_revenue = round(mean(expected_revenue, na.rm = T)),
      expected_annual_revenue = 12 * expected_monthly_revenue
    )
)
```

## Revenue and Receivables

To date, the new system has generated `r scales::dollar(revenue_and_projections$actual_revenue)`. The current Accounts Receivable is `r scales::dollar(revenue_and_projections$accounts_receivable)`. The REDCap ABP monthly revenue is shown according to the month invoiced in @fig-revenue-by-month-invoiced It is shown according to the month the payment was received in @fig-revenue-by-month-received

```{r}
#| label: fig-revenue-by-month-invoiced
#| fig-cap: REDCap APB Revenue generated by the month in which the invoice was sent.
#|   Note that invoices for each month are sent 5-10
#|   days after the end of the month. The first payment is typically not 
#|   received for another two weeks.
#| echo: false
#| warning: false
invoice_status |>
  select(invoice_month, status, amount_due) %>%
  mutate(Status = case_when(
    status == "invoiced" ~ "Not Paid",
    status == "paid" ~ "Paid",
  )) |>
  mutate(
    `Month Invoiced` = as_date(floor_date(invoice_month, unit = "month"))
  ) |>
  group_by(Status, `Month Invoiced`) |>
  summarise(
    amount_invoiced = sum(amount_due)
  ) |>
  ggplot(mapping = aes(x = `Month Invoiced`, fill = Status, y = amount_invoiced)) +
  geom_bar(position = "dodge", stat = "identity") +
  scale_y_continuous(
    labels = dollar,
    limits = c(0, max(revenue$invoices_sent))
    ) +
  scale_x_date(date_breaks = "2 month", date_labels = "%Y-%m") +
  theme(axis.text.x = element_text(angle = 30)) +
  geom_text(aes(y = amount_invoiced, label = amount_invoiced),
    vjust = -0.5, position = position_dodge(width = 0.9), size = 2
  ) +
  xlab("Month Invoiced") +
  ylab("Amount")

```

```{r}
#| label: revenue-by-month-received
#| include: false
revenue_by_month_received <- invoice_status |>
  select(je_posting_date, status, amount_due) |>
  filter(status == "paid") |>
  mutate(
    Status = "Paid",
    `Month Received` = as_date(floor_date(je_posting_date, unit = "month"))
  ) |>
  group_by(Status, `Month Received`) |>
  summarise(
    amount_received = sum(amount_due)
  ) |>
  ungroup()

# write_out actuals for completed months to other scripts to consume
revenue_by_month_received |>
  ungroup() |>
  mutate(revenue_code = "redcap_apb") |>
  rename(
    payment_date = `Month Received`,
    amount = amount_received
  ) |>
  select(
    revenue_code,
    payment_date,
    amount
  ) |>
  filter(payment_date < floor_date(today(), unit = "month")) |>
  write_csv(file = here::here("output", "red_team_auxiliary_revenue_actuals_redcap_apb.csv"))
```

```{r}
#| label: fig-revenue-by-month-received
#| fig-cap: REDCap APB Revenue generated by the month in which the journal entry was posted.
#| echo: false
#| warning: false
revenue_by_month_received |>
  ggplot(mapping = aes(x = `Month Received`, fill = Status, y = amount_received)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(
    labels = dollar,
    limits = c(0, max(revenue$invoices_sent))
  ) +
  scale_x_date(date_breaks = "2 month", date_labels = "%Y-%m") +
  theme(axis.text.x = element_text(angle = 30)) +
  geom_text(aes(y = amount_received, label = amount_received),
    vjust = -0.5,
    size = 2
  ) +
  xlab("Month Received") +
  ylab("Amount")
```

```{r}
#| label: revenue_by_month_received_with_projections
#| echo: false
#| warning: false

# Actuals from all completed months
revenue_by_month_received_actuals <- revenue_by_month_received |>
      filter(lubridate::ceiling_date(`Month Received`, unit = "month") < today())

# Actuals from last 12 completed months, rescaled according to the rate change
# applied 1 months after it went in to effect, softened halfway towards the mean, 
# and moved 12 months forward in time
revenue_by_month_received_12mo_of_estimates <- revenue_by_month_received_actuals |>
      slice_tail(n = 12) |>
      mutate(estimated_revenue = if_else(`Month Received` < ymd("2023-11-15"),
                                        amount_received * 1.30,
                                        amount_received)) |>
      mutate(`Month Received` = `Month Received` + years(1)) |>
      # Soften the peaks and valleys of the expected revenue
      mutate(estimated_revenue = round((estimated_revenue + mean(estimated_revenue)) / 2)) |>
      mutate(amount_received = NA_real_)

revenue_by_month_received_another_12_mo_of_estimates <- 
  revenue_by_month_received_12mo_of_estimates |>
  mutate(estimated_revenue = mean(estimated_revenue)) |>
  mutate(`Month Received` = `Month Received` + years(1))

revenue_by_month_received_with_projections <-
  bind_rows(
    revenue_by_month_received_actuals,
    revenue_by_month_received_12mo_of_estimates,
    revenue_by_month_received_another_12_mo_of_estimates
  ) |>
  mutate(month_received = lubridate::as_datetime(
    `Month Received`,
    tz = Sys.getenv("TIME_ZONE")
  ) + days(1)) |>
  cross_join(rcc.billing::fiscal_years) |>
  filter(month_received %within% fy_interval) |>
  rename(FY = csbt_label) |>
  select(-c(Status, fy_interval, month_received)) |>
  rowwise() |>
  mutate(actuals_and_estimated = sum(amount_received, estimated_revenue, na.rm = T)) |>
  add_count(FY) |>
  filter(n == 12 | FY == "2022-2023") |>
  select(-n)

revenue_by_fy_received_with_projections <- revenue_by_month_received_with_projections |>
  group_by(FY) |>
  summarize(
    Revenue = sum(amount_received, na.rm = T),
    `Estimated Revenue` = sum(estimated_revenue, na.rm = T),
    `Actual Plus Estimated Revenue` = sum(actuals_and_estimated, na.rm = T),
    `Months included` = n()
  ) |>
  ungroup()
```

## Revenue and projections by fiscal year

@fig-revenue-by-month-received-with-projections shows actual revenue by fiscal year with an additional 12 months of projected revenue. These projections are based on the previous 12 months of actual revenue, corrected for the 11/2023 rate change.

```{r}
#| label: fig-revenue-by-month-received-with-projections
#| fig-cap: REDCap APB Revenue by FY with 12 months of projected revenue. 
#| echo: false
#| warning: false
revenue_by_fy_received_with_projections |>
  mutate(across(where(is.double), scales::dollar))
```

The revenue estimates in this section differ from those in the other sections. They strictly separate estimates from actual revenue. These estimate will probably replace those elsewhere in the report.

## Payments Rates and Projections

Projecting potential revenue for the project requires an estimate of the portion of invoices that are likely to be paid. The history of payment in past months informs estimates of future payment, yet there are some issues in those data. The REDCap APB project uses several methods to reduce the number of abandoned projects that get invoiced. Yet many of these methods were developed after the start of the project. Other methods had implementation issues in the early months of the project. As such, it is reasonable to expect the early months of the project will have lower payment rates than later months due to these process refinements. We will use the historic payment rates to estimate future payment with the understanding these estimates of payment rate are probably conservative.

We will estimate the payment rate based on the historic data, but we will ignore the last 4 months of invoicing. This will allow the invoices to age and allow payment incentives like past due reminders and sequestration for non-payment to have their effect to incentivize payment. Using this constraint, the average historic payment rate we will use for estimating revenue is `r scales::percent(average_portion_paid)`

Using the historic payment rate, and the actual number of invoices sent, we can project revenue for recent and future months to get a projected monthly revenue of `r scales::dollar(revenue_and_projections$expected_monthly_revenue)` and an expected annual revenue of `r scales::dollar(revenue_and_projections$expected_annual_revenue)`

```{r}
#| label: project-status
#| echo: false
#| warning: false

rc_conn <- connect_to_redcap_db()

invoice_line_items <- tbl(rcc_billing_conn, "invoice_line_item") %>%
  filter(service_type_code == 1) %>%
  arrange(desc(created)) %>%
  collect() %>%
  distinct(service_identifier, .keep_all = T) %>%
  mutate(service_identifier = as.numeric(service_identifier))

redcap_projects <- tbl(rc_conn, "redcap_projects") %>% collect()
redcap_entity_project_ownership <- tbl(rc_conn, "redcap_entity_project_ownership") %>% collect()

project_status <-
  redcap_projects %>%
  left_join(
    redcap_entity_project_ownership %>% select(-id, -created, -updated),
    by = c("project_id" = "pid")
  ) %>%
  left_join(invoice_line_items,
    by = c("project_id" = "service_identifier"),
    suffix = c(".project", ".invoice")
  ) %>%
    mutate(
      status.active = last_logged_event >= get_script_run_time() - dmonths(2),
      status.mature = creation_time >= get_script_run_time() - dyears(1),
      status.deleted = !is.na(date_deleted),
      status.canceled = status.invoice == "canceled",
      status.invoiced = status.invoice == "invoiced",
      status.paid = status.invoice == "paid",
      status.sent = status.invoice == "sent",
      status.sequestered = sequestered == 1,
      status.non_billable = billable == 1,
      status.could_not_have_been_billed =
        creation_time + dmonths(11) >= today() |
        month(creation_time) %in% c(8),
      status.overall = case_when(
        status.paid ~ "paid",
        status.deleted ~ "deleted",
        status.sequestered & status.invoiced ~ "invoiced_and_sequestered",
        status.invoiced ~ "invoiced",
        status.non_billable & !status.could_not_have_been_billed & !status.deleted & !status.sequestered ~ "non-billable opportunity",
        status.canceled & status.active ~ "erroneously_canceled opportunity",
        status.canceled ~ "canceled",
        status.sent ~ "sent",
        status.sequestered ~ "sequestered",
        status.could_not_have_been_billed ~ "could_not_yet_have_been_billed",
        status.non_billable ~ "non-billable",
        T ~ "other opportunity"
      )
    ) %>%
    select(
      project_id,
      starts_with("status"),
      creation_time,
      -c(status.project, status.invoice)
    )
```

## Lost revenue

There is reason to believe we are leaving some revenue on the table. There are `r nrow(project_status)` projects in the REDCap project table. Their overall status is shown in @fig-overall-status

```{r}
#| label: fig-overall-status
#| fig-cap: Overall project status
#| echo: false
#| warning: false
project_status %>%
  count(status.overall) %>%
  arrange(desc(n))
```

Of note are the statuses in @fig-opportunities

```{r}
#| label: fig-opportunities
#| fig-cap: Income opportunities we should pursue
#| echo: false
#| warning: false
project_status %>%
  filter(str_detect(status.overall, "opportunity")) %>%
  count(status.overall) %>%
  arrange(desc(n))
```

```{r}
#| label: project-lifecycle-income-forecast-df
#| echo: false
#| warning: false
project_lifecycle_income_forecast <-
  project_status %>%
  mutate(income_status = case_when(
    status.deleted | status.sequestered ~ "deleted",
    status.non_billable ~ "not billable",
    T ~ "created"
  )) %>%
  mutate(income_status = factor(income_status, levels = c(
    "deleted",
    "not billable",
    "created"
  )
  )) %>%
  mutate(creation = as.Date(floor_date(creation_time, unit = "month"))) %>%
  mutate(income_source = if_else(income_status == "created" & creation_time < get_script_run_time() - dmonths(1), 1, 0)) %>%
  mutate(cumulative_income_source = cumsum(income_source)) %>%
  select(project_id, creation, income_status, cumulative_income_source)
  
maturity_date <- as.Date(floor_date(get_script_run_time() - dyears(1), unit = "month"))
cumulative_income_source_at_maturity <- project_lifecycle_income_forecast %>%
  filter(creation == maturity_date) %>%
  summarise(cumulative_income_source = max(cumulative_income_source)) %>%
  pull(cumulative_income_source)
```

## Projecting income from extant billable projects

To continue to make money in this venture, we need extant, billable projects. We need new projects to offset the deletion rate of old projects. As a first blush view of our extant and future income sources, @fig-project-lifecycle-income-forecast shows every extant project by creation date. The projects are shown with one of 3 categories: *Created* projects could be billed when they reach maturity. *Non-billable* projects are CTS-IT's projects and cannot be billed. *Deleted* projects are not viable for billing going forward. The category includes sequestered projects. The black line shows the cumulative sum of *created* projects. It shows `r cumulative_income_source_at_maturity` projects that could (should?) be sources of income.

```{r}
#| label: fig-project-lifecycle-income-forecast
#| fig-cap: Income forecast based on project lifecycle
#| echo: false
#| warning: false
ggplot(
  project_lifecycle_income_forecast,
  aes(fill = income_status, x = creation)
) +
  geom_bar(position = "stack") +
  geom_line(mapping = aes(y = cumulative_income_source)) +
  ylab("Projects") +
  xlab("Months") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  theme(axis.text.x = element_text(angle = 45),
        axis.text = element_text(size = 8)) +
  geom_vline(aes(xintercept = maturity_date)) +
  annotate("segment",
           x = as.Date(maturity_date - dyears(1)),
           y = cumulative_income_source_at_maturity,
           xend = maturity_date,
           yend = cumulative_income_source_at_maturity,
           arrow = arrow(type = "open", length = unit(0.02, "npc"))) +
  annotate("text",
           x = as.Date(maturity_date - dyears(1)),
           y = cumulative_income_source_at_maturity,
           label = paste(cumulative_income_source_at_maturity, "projects at maturity"),
           hjust = 1) +
  geom_text(aes(
    x = maturity_date,
    y = cumulative_income_source_at_maturity,
    label = paste(
      "maturity date:",
      maturity_date
    ),
    angle = 90,
    vjust = 0.0,
    hjust = 0.0
  ))
```

## Aging Report

The unpaid invoices breakdown as shown in @fig-aging-report

```{r}
#| label: fig-aging-report
#| fig-cap: Unpaid invoices grouped by age
#| echo: false
#| warning: false

invoice_status %>%
  filter(status == "invoiced") %>%
  select(invoice_month, status, amount_due, created) %>%
  mutate(age_in_days = now() - created) %>%
  mutate(`Aging Group` = as_factor(case_when(
    age_in_days <= 30 ~ "0-30 days",
    age_in_days <= 60 ~ "31-60 days",
    age_in_days <= 90 ~ "61-90 days",
    age_in_days <= 120 ~ "91-120 days",
    TRUE ~ "120+ days"
  ))) %>%
  count(`Aging Group`, name = "Invoices") %>%
  arrange(desc(`Aging Group`))

```

## Report summary

-   Revenue since inception: `r scales::dollar(revenue_and_projections$actual_revenue)`

-   Accounts Receivable since inception: `r scales::dollar(revenue_and_projections$accounts_receivable)`

-   Average historic payment rate: `r scales::percent(average_portion_paid)`

-   Projected annual revenue: `r scales::dollar(revenue_and_projections$expected_annual_revenue)`
