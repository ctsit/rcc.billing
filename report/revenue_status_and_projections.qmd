---
title: "REDCap Annual Project Billing Revenue, Status, and Projections"
author: "Philip Chase"
format:
  html:
    code-fold: true
    code-tools: true
    df-print: kable
  pdf:
    geometry:
      - margin=19mm
      - bottom=30mm
    fig-pos: 'H'
    df-print: kable
editor: visual
date: "`r Sys.Date()`"
---

The CTS-IT manages the REDCap system for the UF Clinical Translational Science Institute (CTSI). To generate revenue to cover some of the costs of the running the REDCap System, CTS-IT charges its customers for the REDCap projects they use. These annual charges are assessed on each anniversary of each project via a system named *REDCap Annual Project Billing (APB)*. This report describes that project by assessing the revenue, estimating future revenue, as well as other metrics of growth and performance.

While the original billing system started in July 2018, that system was rewritten from the ground up in 2022. The revision focuses on automated processes to implement a monthly billing cycle and delegates the billing work to the UF CTSI Service Billing Team. The new system was implemented in September 2022.

```{r}
#| label: calcs
#| output: false
#| echo: false
#| warning: false
library(redcapcustodian)
library(rcc.billing)
library(RMariaDB)
library(DBI)
library(tidyverse)
library(lubridate)
library(dotenv)
library(fs)
library(scales)

if (Sys.getenv("RCCBILLING_DB_NAME") == "") dotenv::load_dot_env(here::here("prod.env"))

init_etl("revenue_status_and_projections")

rcc_billing_conn <- connect_to_rcc_billing_db()

invoice_status <-
  tbl(rcc_billing_conn, "invoice_line_item") %>%
  collect() %>%
  mutate(invoice_month = lubridate::floor_date(created - dmonths(1), unit = "month")) %>%
  filter(status %in% c("invoiced", "paid"))

revenue <-
  tbl(rcc_billing_conn, "invoice_line_item") %>%
  collect() %>%
  mutate(invoice_month = lubridate::floor_date(created - dmonths(1), unit = "month")) %>%
  filter(status != "canceled") %>%
  group_by(status, invoice_month) %>%
  summarise(total = sum(amount_due)) %>%
  tidyr::pivot_wider(
    id_cols = c("invoice_month"),
    names_from = status,
    values_from = total
  ) %>%
  mutate(
    invoices_sent = invoiced + coalesce(paid, 0),
    portion_paid = coalesce(paid, 0) / invoices_sent
  ) |>
  ungroup() |>
  arrange(invoice_month)

# The average portion paid should ignore the last three months as sequester_unpaid_projects has not yet been applied to these months
average_portion_paid <- revenue %>%
  slice_head(n = nrow(revenue) - 4) %>%
  summarise(average_portion_paid = mean(portion_paid)) %>%
  pull(average_portion_paid)

expected_revenue <- revenue %>%
  mutate(expected_revenue = case_when(
    row_number() <= nrow(revenue) - 4 ~ paid,
    TRUE ~ round(coalesce(invoices_sent, sent) * average_portion_paid)
  ))

revenue_and_projections <- bind_cols(
  expected_revenue %>%
    summarise(
      actual_revenue = sum(paid, na.rm = T),
      accounts_receivable = sum(invoiced, na.rm = T)
    ),
  # Base expected revenue only on the last 12 months of revenue
  expected_revenue |>
    slice_tail(n = 12) |>
    # correct expected revenue for the rate increase that started 2023-11-01
    mutate(expected_revenue = if_else(invoice_month < ymd("2023-10-15"), expected_revenue * 1.30, expected_revenue)) |>
    summarise(
      expected_monthly_revenue = round(mean(expected_revenue, na.rm = T)),
      expected_annual_revenue = 12 * expected_monthly_revenue
    )
)
```

## Revenue and Receivables

To date, the new system has generated `r scales::dollar(revenue_and_projections$actual_revenue)`. The current Accounts Receivable is `r scales::dollar(revenue_and_projections$accounts_receivable)`. The REDCap ABP monthly revenue is shown according to the month invoiced in @fig-revenue-by-month-invoiced It is shown according to the month the payment was received in @fig-revenue-by-month-received

```{r}
#| label: fig-revenue-by-month-invoiced
#| fig-cap: REDCap APB Revenue generated by the month in which the invoice was sent.
#|   Note that invoices for each month are sent 5-10
#|   days after the end of the month. The first payment is typically not 
#|   received for another two weeks.
#| echo: false
#| warning: false
invoice_status |>
  select(invoice_month, status, amount_due) %>%
  mutate(Status = case_when(
    status == "invoiced" ~ "Not Paid",
    status == "paid" ~ "Paid",
  )) |>
  mutate(
    `Month Invoiced` = as_date(floor_date(invoice_month, unit = "month"))
  ) |>
  group_by(Status, `Month Invoiced`) |>
  summarise(
    amount_invoiced = sum(amount_due)
  ) |>
  ggplot(mapping = aes(x = `Month Invoiced`, fill = Status, y = amount_invoiced)) +
  geom_bar(position = "dodge", stat = "identity") +
  scale_y_continuous(
    labels = dollar,
    limits = c(0, max(revenue$invoices_sent))
    ) +
  scale_x_date(date_breaks = "2 month", date_labels = "%Y-%m") +
  theme(axis.text.x = element_text(angle = 30)) +
  geom_text(aes(y = amount_invoiced, label = amount_invoiced),
    vjust = -0.5, position = position_dodge(width = 0.9), size = 2
  ) +
  xlab("Month Invoiced") +
  ylab("Amount")

```

```{r}
#| label: revenue-by-month-received
#| include: false
revenue_by_month_received <- invoice_status |>
  select(je_posting_date, status, amount_due) |>
  filter(status == "paid") |>
  mutate(
    Status = "Paid",
    `Month Received` = as_date(floor_date(je_posting_date, unit = "month"))
  ) |>
  group_by(Status, `Month Received`) |>
  summarise(
    amount_received = sum(amount_due)
  ) |>
  ungroup()

# write_out actuals for completed months to other scripts to consume
revenue_by_month_received |>
  ungroup() |>
  mutate(revenue_code = "redcap_apb") |>
  mutate(revenue_description = "REDCap Billing") |>
  rename(
    payment_date = `Month Received`,
    amount = amount_received
  ) |>
  select(
    revenue_code,
    revenue_description,
    payment_date,
    amount
  ) |>
  filter(payment_date < floor_date(today(), unit = "month")) |>
  write_csv(file = here::here("output", "red_team_auxiliary_revenue_actuals_redcap_apb.csv"))
```

```{r}
#| label: fig-revenue-by-month-received
#| fig-cap: REDCap APB Revenue generated by the month in which the journal entry was posted.
#| echo: false
#| warning: false
revenue_by_month_received |>
  ggplot(mapping = aes(x = `Month Received`, fill = Status, y = amount_received)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(
    labels = dollar,
    limits = c(0, max(revenue$invoices_sent))
  ) +
  scale_x_date(date_breaks = "2 month", date_labels = "%Y-%m") +
  theme(axis.text.x = element_text(angle = 30)) +
  geom_text(aes(y = amount_received, label = amount_received),
    vjust = -0.5,
    size = 2
  ) +
  xlab("Month Received") +
  ylab("Amount")
```

```{r}
#| label: revenue_by_month_received_with_projections
#| echo: false
#| warning: false

# Actuals from all completed months
revenue_by_month_received_actuals <- revenue_by_month_received |>
      filter(lubridate::ceiling_date(`Month Received`, unit = "month") < today())

# Actuals from last 12 completed months, rescaled according to the rate change
# applied 1 months after it went in to effect, softened halfway towards the mean, 
# and moved 12 months forward in time
revenue_by_month_received_12mo_of_estimates <- revenue_by_month_received_actuals |>
      slice_tail(n = 12) |>
      mutate(estimated_revenue = if_else(`Month Received` < ymd("2023-11-15"),
                                        amount_received * 1.30,
                                        amount_received)) |>
      mutate(`Month Received` = `Month Received` + years(1)) |>
      # Soften the peaks and valleys of the expected revenue
      mutate(estimated_revenue = round((estimated_revenue + mean(estimated_revenue)) / 2)) |>
      mutate(amount_received = NA_real_)

revenue_by_month_received_another_12_mo_of_estimates <- 
  revenue_by_month_received_12mo_of_estimates |>
  mutate(estimated_revenue = mean(estimated_revenue)) |>
  mutate(`Month Received` = `Month Received` + years(1))

revenue_by_month_received_with_projections <-
  bind_rows(
    revenue_by_month_received_actuals,
    revenue_by_month_received_12mo_of_estimates,
    revenue_by_month_received_another_12_mo_of_estimates
  ) |>
  mutate(month_received = lubridate::as_datetime(
    `Month Received`,
    tz = Sys.getenv("TIME_ZONE")
  ) + days(1)) |>
  cross_join(rcc.billing::fiscal_years) |>
  filter(month_received %within% fy_interval) |>
  rename(FY = csbt_label) |>
  select(-c(Status, fy_interval, month_received)) |>
  rowwise() |>
  mutate(actuals_and_estimated = sum(amount_received, estimated_revenue, na.rm = T)) |>
  add_count(FY) |>
  filter(n == 12 | FY == "2022-2023") |>
  select(-n)

revenue_by_fy_received_with_projections <- revenue_by_month_received_with_projections |>
  group_by(FY) |>
  summarize(
    Revenue = sum(amount_received, na.rm = T),
    `Estimated Revenue` = sum(estimated_revenue, na.rm = T),
    `Actual Plus Estimated Revenue` = sum(actuals_and_estimated, na.rm = T),
    `Months included` = n()
  ) |>
  ungroup()
```

## Revenue and projections by fiscal year

@fig-revenue-by-month-received-with-projections shows actual revenue by fiscal year with an additional 12 months of projected revenue. These projections are based on the previous 12 months of actual revenue, corrected for the 11/2023 rate change.

```{r}
#| label: fig-revenue-by-month-received-with-projections
#| fig-cap: REDCap APB Revenue by FY with 12 months of projected revenue. 
#| echo: false
#| warning: false
revenue_by_fy_received_with_projections |>
  mutate(across(where(is.double), scales::dollar))
```

## Aging Report

Excluding the last 4 months of invoicing, the historic payment rate `r scales::percent(average_portion_paid)`. The unpaid invoices breakdown as shown in @fig-aging-report

```{r}
#| label: fig-aging-report
#| fig-cap: Unpaid invoices grouped by age
#| echo: false
#| warning: false

invoice_status %>%
  filter(status == "invoiced") %>%
  select(invoice_month, status, amount_due, created) %>%
  mutate(age_in_days = now() - created) %>%
  mutate(`Aging Group` = as_factor(case_when(
    age_in_days <= 30 ~ "0-30 days",
    age_in_days <= 60 ~ "31-60 days",
    age_in_days <= 90 ~ "61-90 days",
    age_in_days <= 120 ~ "91-120 days",
    TRUE ~ "120+ days"
  ))) %>%
  count(`Aging Group`, name = "Invoices") %>%
  arrange(desc(`Aging Group`))
```

```{r}
#| label: project-status
#| echo: false
#| warning: false

rc_conn <- connect_to_redcap_db()

invoice_line_items <- tbl(rcc_billing_conn, "invoice_line_item") %>%
  filter(service_type_code == 1) %>%
  arrange(desc(created)) %>%
  collect() %>%
  distinct(service_identifier, .keep_all = T) %>%
  mutate(service_identifier = as.numeric(service_identifier))

redcap_projects <- tbl(rc_conn, "redcap_projects") %>% collect()
redcap_entity_project_ownership <- tbl(rc_conn, "redcap_entity_project_ownership") %>% collect()

project_status <-
  redcap_projects %>%
  left_join(
    redcap_entity_project_ownership %>% select(-id, -created, -updated),
    by = c("project_id" = "pid")
  ) %>%
  left_join(invoice_line_items,
    by = c("project_id" = "service_identifier"),
    suffix = c(".project", ".invoice")
  ) %>%
    mutate(
      status.active = last_logged_event >= get_script_run_time() - dmonths(2),
      status.mature = creation_time >= get_script_run_time() - dyears(1),
      status.deleted = !is.na(date_deleted),
      status.canceled = status.invoice == "canceled",
      status.invoiced = status.invoice == "invoiced",
      status.paid = status.invoice == "paid",
      status.sent = status.invoice == "sent",
      status.sequestered = sequestered == 1,
      status.non_billable = billable == 1,
      status.could_not_have_been_billed =
        creation_time + dmonths(11) >= today() |
        month(creation_time) %in% c(8),
      status.overall = case_when(
        status.paid ~ "paid",
        status.deleted ~ "deleted",
        status.sequestered & status.invoiced ~ "invoiced_and_sequestered",
        status.invoiced ~ "invoiced",
        status.non_billable & !status.could_not_have_been_billed & !status.deleted & !status.sequestered ~ "non-billable opportunity",
        status.canceled & status.active ~ "erroneously_canceled opportunity",
        status.canceled ~ "canceled",
        status.sent ~ "sent",
        status.sequestered ~ "sequestered",
        status.could_not_have_been_billed ~ "could_not_yet_have_been_billed",
        status.non_billable ~ "non-billable",
        T ~ "other opportunity"
      )
    ) %>%
    select(
      project_id,
      starts_with("status"),
      creation_time,
      -c(status.project, status.invoice)
    )
```

## Possible revenue opportunities

There is reason to believe we are leaving some revenue on the table. There are `r nrow(project_status)` projects in the REDCap project table. Their overall status is shown in @fig-overall-status

```{r}
#| label: fig-overall-status
#| fig-cap: Overall project status
#| echo: false
#| warning: false
project_status %>%
  count(status.overall) %>%
  arrange(desc(n))
```

Of note are the statuses in @fig-opportunities

```{r}
#| label: fig-opportunities
#| fig-cap: Income opportunities we should pursue
#| echo: false
#| warning: false
project_status %>%
  filter(str_detect(status.overall, "opportunity")) %>%
  count(status.overall) %>%
  arrange(desc(n))
```

